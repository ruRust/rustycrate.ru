---
layout: post
categories: обучение
title: "Rust: str vs String"
author: Ameya
original: http://www.ameyalokare.com/rust/2017/10/12/rust-str-vs-String.html
translator: Norman Ritchie
---

Будучи новичком в Rust, я запутывался в различных способах обозначить строку.
В книге о языке Rust есть глава [“References and Borrowing”][ref], в которой
используется три различных типа строковых переменных в примерах: `String`, `&String` и `&str`.

[ref]: https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html

Начнём с разницы между `str` и `String`: `String` — это расширяемая, выделяемая на куче структура данных, тогда как `str` — это неизменяемая строка фиксированной длины, *где-то* в памяти.

<!--cut-->

### String

Если вы программируете на Java, `String` в Rust семантически эквивалентен `StringBuffer` (вероятно это являлось причиной моего замешательства, поскольку я привык приравнивать `String` с неизменяемостью). Таким образом, `String` содержит длину *и* вместимость, тогда как `str` содержит только один метод `len()`. В качестве примера:

```rust
let mut s = String::from("Привет, Rust!");
println!("{}", s.capacity()); // напечатает 19
s.push_str("Вот и я!");
println!("{}", s.len()); // напечатает 32

let s = "Привет, Rust!";
// ошибка компиляции: для типа `str` не найден
// метод с именем `capacity`.
println!("{}", s.capacity());

println!("{}", s.len()); // напечатает 19
```

### &str

Вы можете взаимодействовать с `str` в качестве заимствованного типа `&str`. Это называется *строковый срез (слайс)*, неизменяемое представление строки. Как мы увидим, этот способ является предпочтительным для передачи строк.

### &String

Это ссылка на `String`, которая также является *заимствованным* типом. Это не более чем указатель, который вы можете передать, не передавая владение. Получается, что `&String` можно *преобразовать* в `&str`:

```rust
fn main() {
    let s = String::from("Привет, Rust!");
    foo(&s);
}

fn foo(s: &str) {
    println!("{}", s);
}
```

В приведённом выше примере, `foo()` может принимать любой строковый срез (слайс) или заимствованный `String`, что очень удобно. Таким образом, вам почти никогда не надо иметь дело со `&String`. Единственный случай применения, который приходит мне в голову — если вы хотите передать изменяемую ссылку в функцию, которая должна изменить строку:

```rust
fn main() {
    let mut s = String::from("Привет, Rust!");
    foo(&mut s);
}

fn foo(s: &mut String) {
    s.push_str("добавим foo..");
    println!("{}", s);
}
```

### Подводя итог

Предпочитайте `&str`, чтобы передать параметр в функцию или если вам нужно неизменяемое представление строки. А `String`, когда вы хотите владеть и изменять строку.

1. Данные `str` могут находиться в куче, стеке или в бинарном формате. [Этот][stack] отличный ответ на stackoverflow объясняет каждый случай.

[stack]: https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str/24159933#24159933
