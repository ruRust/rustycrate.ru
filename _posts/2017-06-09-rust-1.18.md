---
layout: post
categories: новости
title: "Выпуск Rust 1.18"
author: The Rust Core Team
original: https://blog.rust-lang.org/2017/06/08/Rust-1.18.html
translator: Илья Богданов
---

Команда Rust рада представить выпуск Rust 1.18.0. Rust - это системный язык
программирования, нацеленный на безопасность, скорость и параллельное выполнение
кода.

Если у вас установлена предыдущая версия Rust, то для обновления достаточно
выполнить:

```bash
$ rustup update stable
```

Если у вас ещё не установлен Rust, вы можете [установить `rustup`][install] c
соответствующей страницы нашего веб-сайта и ознакомиться с
[подробным примечанием к выпуску 1.18.0][notes] на GitHub.

<!--cut-->

[install]: https://www.rust-lang.org/install.html
[notes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1180-2017-06-08

### Что вошло в стабильную версию 1.18.0

Как и всегда, Rust 1.18.0 собрал в себе множество улучшений и новых возможностей.

Одно из крупнейших и самых ожидаемых изменений: члены команды Carol Nichols и
Steve Klabnik пишут новую редакцию "Язык программирования Rust", официальной
книги о Rust. Она пишется [открыто на GitHub](https://github.com/rust-lang/book),
и уже более ста человек внесли в нее свой вклад. Этот выпуск
[включает первый черновой вариант второго издания в нашей онлайн документации](https://doc.rust-lang.org/stable/book/)
. 19 из 20 глав уже написаны, черновой вариант 20 главы будет добавлен в выпуске
Rust 1.19. Когда книга будет завершена, версия для печати будет доступна через
[No Starch Press](https://www.nostarch.com/Rust), если вы предпочитаете бумажную
копию. Мы все еще работаем совместно с редакторами No Startch, чтобы улучшить
текст, но мы бы хотели представить книгу широкой аудитории уже сейчас.

Новое издание написано полностью с нуля, используя знания, полученные
нами за последние два года обучения людей Rust. Вы найдете совершенно новые
объяснения множества ключевых концепций Rust, новые проекты для обучения, и
много других интересных и полезных вещей. Пожалуйста, взгляните и [сообщите нам, что думаете](https://github.com/rust-lang/book/issues/new)!

Что касается самого языка, старые функции получили новые возможности: ключевое
слово `pub` было немного расширено. Опытные программисты Rust знают, что в Rust
все элементы приватны по умолчанию, и вы должны использовать ключевое слово `pub`,
чтобы сделать их публичными. В Rust 1.18.0 `pub`
[получило новую форму](https://github.com/rust-lang/rust/pull/40556):

```rust
pub(crate) bar;
```

Выражение внутри `()` является 'ограничением', уточняющим область видимости.
Использование ключевого слова `crate` в примере выше означает, что `bar` будет
публичным для всего контейнера (crate), но не вне него. Это упрощает создание
API, которые "публичны для вашего контейнера", но не доступны вашим пользователям.
Это было *возможно* с существующей системой модулей, но очень часто выглядело
неудобно.


Вы также можете указать путь, например:

```rust
pub(in a::b::c) foo;
```

Это означает "`foo` публично внутри иерархии `a::b::c`, но нигде больше". Эта особенность
была определена в [RFC 1422](https://github.com/rust-lang/rfcs/blob/master/text/1422-pub-restricted.md)
и [описана в документации](https://doc.rust-lang.org/stable/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself).

Для пользователей Windows, Rust 1.18.0 имеет
[новый атрибут, `#![windows_subsystem]`](https://github.com/rust-lang/rust/pull/40870).
Это работает так:

```rust
#![windows_subsystem = "console"]
#![windows_subsystem = "windows"]
```

Эти выражения контролируют [флаг `/SUBSYSTEM`](https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx)
компоновщика. В настоящий момент, доступны только `console` и `windows`.

Когда это может быть полезным? В простейшем случае, если вы разрабатываете
графическое приложение, и не указали `windows`, окно консоли будет появляться при
старте вашего приложения. С этим флагом, этого не произойдет.

Наконец, кортежи, перечисления и структуры (без `#[repr]`) всегда имели
неопределенное размещение в памяти. [Мы включили автоматическое переупорядочивание](https://github.com/rust-lang/rust/pull/40377),
что может привести к меньшим размерам структур.
Представьте следующую структуру:

```rust
struct Suboptimal(u8, u16, u8);
```

В предыдущих версиях Rust на платформе x86_64, эта структура будет занимать в
памяти шесть байт. Но смотря на код, вы ожидаете только 4. Дополнительные два
байта появляются из-за выравнивания: так как наибольший тип в структуре `u16`,
она должна быть выравнена по два байта. Но в этом случае `u16` расположено в
памяти со смещением в один байт. Чтобы разместить его со смещением в два байта,
нужно добавить еще один байт выравнивания после первого `u8`. Добавив еще один
байт после второго `u8`,
получаем `1 + 1 (выравнивание) + 2 + 1 + 1 (выравнивание) = 6 байт`.

Но что, если наша структура выглядит так?

```rust
struct Optimal(u8, u8, u16);
```

Эта структура выровнена оптимально; `u16` лежит с выравниванием в два байта,
как и вся структура в целом. Никакого выравнивания не требуется. Это дает нам
`1 + 1 + 2 = 4 байт`.

Проектируя Rust, мы оставили детали размещения в памяти неопределенными именно по
этой причине. Не придерживаясь определенной политики, мы можем вносить оптимизации,
например, как в этом случае, когда компилятор может оптимизировать `Suboptimal`
в `Optimal` автоматически. И если вы проверите размеры `Suboptimal` и `Optimal`
в Rust 1.18.0, вы увидите, что они обе имеют размер 4 байта.

Мы планировали это изменение в течение длительного времени; предыдущие версии
Rust включали эту оптимизацию в ночных (nightly) сборках, но некоторые люди
писали небезопасный код, который требовал точных данных о размещении в памяти.
Мы откатили это изменение и исправили все подобные случаи, о которых знали. Но
если вы найдете какой-нибудь код, который работает неправильно, [сообщите нам](https://github.com/rust-lang/rust/issues),
чтобы мы смогли его исправить!

Мы планировали перенести `rustdoc` на Markdown-совместимый парсер CommonMark в
течение долгого времени. Однако, простой переход может привести к проблемам, так
как спецификация CommonMark отличается от нашего текущего парсера, Hoedown. Как
часть нашего плана перехода, [новый флаг был добавлен в `rustdoc`](https://github.com/rust-lang/rust/pull/40338),
`--enable-commonmark`. Этот флаг включает использование нового парсера вместо
старого. Пожалуйста попробуйте его! Насколько мы знаем, оба парсера производят
одинаковые результаты, но мы хотим знать, если вы найдете сценарий, при котором
их результаты отличаются!

Наконец, компиляция самого `rustc` теперь [на 15%-20% быстрее](https://github.com/rust-lang/rust/pull/41469).
Сообщения коммитов в этом PR содержат некоторые детали; существовало множество
неэффективных мест, но теперь все они исправлены.

Смотрите [подробные заметки о выпуске][notes] для подробностей.

#### Стабилизация стандартной библиотеки

Семь новых API были стабилизированы в этом выпуске:

- [`Child::try_wait`], неблокирующая версия `Child::wait`.
- [`HashMap::retain`] и [`HashSet::retain`] добавляют `retain` из API `Vec<T>` для этих двух хранилищ.
- [`PeekMut::pop`] позволяет вам вытащить верхний элемент из `BinaryHeap<T>` после того как вы уже прочитали его без необходимости упорядочивать кучу второй раз.
- [`TcpStream::peek`], [`UdpSocket::peek`], [`UdpSocket::peek_from`] позволяют вам просматривать поток или сокет.

[`Child::try_wait`]: https://doc.rust-lang.org/std/process/struct.Child.html#method.try_wait
[`HashMap::retain`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.retain
[`HashSet::retain`]: https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.retain
[`PeekMut::pop`]: https://doc.rust-lang.org/std/collections/binary_heap/struct.PeekMut.html#method.pop
[`TcpStream::peek`]: https://doc.rust-lang.org/std/net/struct.TcpStream.html#method.peek
[`UdpSocket::peek_from`]: https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.peek_from
[`UdpSocket::peek`]: https://doc.rust-lang.org/std/net/struct.UdpSocket.html#method.peek

Смотрите [подробные заметки о выпуске][notes] для подробностей.

#### Функции Cargo

В Cargo [появилась поддержка](https://github.com/rust-lang/cargo/pull/3842) для
Pijul VCS, написанной на Rust. `cargo new my-awesome-project --vcs=pijul` включает
ее!

В дополнение к флагу `--all`, Cargo теперь имеет [несколько новых флагов](https://github.com/rust-lang/cargo/pull/3901), например `--bins`, `--examples`,
`--tests` и `--benches`, которые позволяют вам собирать все программы заданного
типа.

Наконец, Cargo теперь поддерживает [Haiku](https://github.com/rust-lang/cargo/pull/3952)
и [Android](https://github.com/rust-lang/cargo/pull/3885)!

Смотрите [подробные заметки о выпуске][notes] для подробностей.

### Вклад в 1.18.0

Множество людей участвовало в создании Rust 1.18. Мы не смогли бы этого добиться
без помощи каждого из вас. [Спасибо!](https://thanks.rust-lang.org/rust/1.18.0)