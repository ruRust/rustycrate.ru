---
categories: руководства
title: "Шаблон индексирования для нового типа"
author: Aleksey Kladov
original: https://matklad.github.io/2018/06/03/newtype-index-pattern.html
translator: Александр Андреев
---

Аналогично [предыдущему посту](https://matklad.github.io/2018/05/24/typed-key-pattern.html),
мы попробуем добавить типы к коду Rust, который без них прекрасно работает.
В этот раз мы будем пробовать улучшить наш код с помощью распространенного шаблона
с использованием индексов для управления циклическими структурами данных.

<!--cut-->

# Проблема

Часто приходится работать со структурой данных, которая содержит циклические ссылки
вида: объект `foo` ссылается на `bar`, который ссылается `baz`,
который в свою очередь ссылается на `foo`.
Учебный пример здесь представляет собой граф вершин и ребер.
Однако на практике истинные графы встречаются редко.
Вместо этого, вы скорее всего увидите дерево с указателями на родителей,
которое содержит много тривиальных циклов.
И иногда неявные циклические графы: `Сотрудник (Employee)`
может быть руководителем `Отдела (Department)`,
и в `Отделе (Department)` есть сотрудники `Vec<Employee>`.
Это что-то вроде замаскированного графа: в обычных графах все вершины одного типа,
а вот `Сотрудник (Employee)` и `Отдел (Department)` - это разные типы.

Работать с такими структурами данных сложно на любом языке. Прибывать
в ситуации, когда `A` указывает на `B`, который указывает на `A`, некоторая
форма изменчивости обязательна. Действительно, любой из объектов `A` или `B` может быть
создан первым, и поэтому он может не сразу после
создания указывать на другой объект.
Вы можете документировать эту изменчивость с помощью `let rec`, как в
`OCaml`, как в `Haskell`.

Rust имеет тенденцию обнаруживать проблемы такого вида во время компиляции,
поэтому реализация таких графов в Rust является сложной задачей.
Три обычно применяемых подхода:

  * Подсчет ссылок, более подробно смотрите [здесь][rc],
  * Арена и реальные циклические ссылки, объяснение от
    [simonsapin][arena] (это действительно аккуратно!),
  * Арена числовые индексы, объяснение от [nikomatsakis][idx].

[rc]: https://github.com/nrc/r4cppp/blob/master/graphs/README.md#rcrefcellnode
[arena]: https://exyr.org/2018/rust-arenas-vs-dropck/
[idx]: http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/

(по-видимому, переписывание учебника по монадам в Haskell для Rust
приводит к записям в блоге про графы).

Лично мне больше всего нравится подход с индексами. Однако он представляет
интересную задачу при чтении. С ссылками, вы имеете
`foo` типа `&Foo`, и сразу понятно, что это такое,
и что вы можете с этим сделать. С индексами, однако, у вас есть `foo: usize`,
и не очевидно, что вы каким-то образом можете получить `Foo`.
Даже хуже, если индексы используются для двух типов объектов, таких как `Foo` и
`Bar`, вы можете в конечном итоге получить `thing: usize`. При написании кода с
использованием `usize` на самом деле работает довольно хорошо
(я не думаю, что когда-либо использовал неправильный тип индекса),
чтение его сложнее, потому что `usize` гораздо менее информативно о том,
что вы могли бы сделать с полученным значением.

# Трюк с новым типом

Один из способов обойти эту проблему - это сделать обертку над `usize`:

```rust
struct Foo;

#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
struct FooIdx(usize);

struct Arena {
    foos: Vec<Foo>,
}

impl Arena {
    fn foo(&self, foo: FooIdx) -> &Foo {
        &self.foos[foo.0]
    }
}
```

Здесь, "надо использовать `FooIdx` в `Vec<Foo>`", это только соглашение.
Классная вещь в Rust заключается в том, что мы можем превратить это
соглашение в свойство, проверенное во время проверки типа. Путем добавления
соответствующего `impl`, мы сможем индексировать `Vec<Foo>` с
помощью `FooIdx` напрямую:

```rust
#[test]
fn direct_indexing(foos: Vec<Foo>, idx: FooIdx) {
    let _foo: &Foo = &foos[idx];
}
```

Реализация выглядит так:

```rust
use std::ops;

impl ops::Index<FooIdx> for Vec<Foo> {
    type Output = Foo;

    fn index(&self, index: FooIdx) -> &Foo {
        &self[index.0]
    }
}
```

# Когерентность

Давайте разберемся почему это разрешено в `impl`.
В Rust, типы, типажи и `impls` разделены.
Это создает проблемы: что если есть два блока `impl` для данной пары (типаж, тип)?
Очевидный выбор - запретить иметь два `impls`, и это именно, то что делает Rust.

На самом деле сложно соблюдать это ограничение! Самое простое правило
"ошибка, если набор пакетов содержит повторяющиеся `impls`"
имеет серьезные недостатки. Прежде всего, это глобальная проверка, которая
требуется знание всех скомпилированных пакетов. Эта проверка откладывается
до более поздних стадий компиляции. Эта проблема также создает проблемы с зависимостями,
потому что два совершенно несвязанных пакета могут не
компилироваться, если одновременно присутствует `impl` для пары (типаж, тип).
Более того, компилятор сам не решит проблему, т. к. у него нет всей информации обо всех пакетах.
Например, можно загрузить дополнительный код во время выполнения через динамические библиотеки
и что может произойти, если у программы и динамической библиотеки есть дубликат
`impls`.

Для того чтобы свободно комбинировать пакеты, мы хотим гораздо сильное свойство:
не только для только скомпилированного набора пакетов, но все существующие и
даже будущие пакеты не должны нарушать одно ограничение `impl`. Как это в дальнейшем проверить?
При публикации пакета на `crates.io` через `cargo publish` должно выдаваться предупреждение
о конфликте реализации `impl` для пары (типаж, тип) с уже опубликованными пакетами?

К счастью, и это потрясающе красиво, можно ослабить глобальное ограничение локально.
В самом простом виде, мы может поместить ограничение, что `impl Foo for Bar`
может появиться либо в пакете, который определяет `Foo`, или в том, который определяет
`Bar`. Важно то, какой из них определяет `impl`, должен использовать другой,
что дает возможность обнаружить конфликт.

Это все действительно изящно, но мы только что определили `Index` для
`Vec`, и оба `Index` и `Vec` из стандартной библиотеки! Как
это возможно? Хитрость в том, что `Index` имеет параметр типа:
`trait Index<Idx: ?Sized>`. Это шаблон для типажа, и мы получаем
"реальный" типаж, когда мы подставляем параметр типа. Потому что
`FooIdx` является локальным типом, итоговый `Index<FromIdx>` тоже
считается локальным. Точные правила здесь довольно сложны, [RFC][coh]
объясняет их довольно хорошо.

[coh]: https://github.com/rust-lang/rfcs/pull/2451

# Больше impls

Потому что `Index<FooIdx>` и `Index<BarIdx>` разные типажи, один
тип может реализовать оба типажа. Это удобно для контейнеров
которые содержат различные типы:

```rust
struct Arena {
    foos: Vec<Foo>,
    bars: Vec<Bar>,
}

impl ops::Index<FooIdx> for Arena { ... }

impl ops::Index<BarIdx> for Arena { ... }
```

Также полезно определить арифметические операции и преобразования для
новых типизированных индексов.
Я собрал [`typed_index_derive`][crate], чтобы автоматизировать этот шаблон через
процедурный макрос, конечный результат выглядит следующим образом:

```rust
#[macro_use]
extern crate typed_index_derive;

struct Spam(String);

#[derive(
    // Обычно выводит старые данные
    Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash,

    TypedIndex
)]
#[typed_index(Spam)] // индекс в `&[Spam]`
struct SpamIdx(usize); // может быть `u32` вместо `usize`

fn main() {
    let spams = vec![Spam("foo".into()), Spam("bar".into()), Spam("baz".into())];

    // Преобразования между `usize` и `SpamIdx`
    let idx: SpamIdx = 1.into();
    assert_eq!(usize::from(idx), 1);

    // Индексирование `Vec<Spam>` с помощью `SpamIdx`, `IndexMut` работает хорошо
    assert_eq!(&spams[idx].0, "bar");

    // Индексирование `Vec<usize>` по праву запрещено
    // vec![1, 2, 3][idx]
    // ошибка: индексы среза типа `usize` или для диапазонов типа `usize`

    // Можно добавить сложение / вычитание `usize` из индекса
    assert_eq!(&spams[idx - 1].0, "foo");

    // Разность между двумя индексами выраженная через `usize`
    assert_eq!(idx - idx, 0usize);
}
```

[crate]: https://crates.io/crates/typed_index_derive

Обсуждение [/r/rust](https://www.reddit.com/r/rust/comments/8ohaj4/blog_post_newtype_index_pattern/).